using System;
using System.Collections.Generic;
using System.IO;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;
using System.Xml;

namespace ReadRSAKey
{
    internal class Program
    {
        static async Task Main(string[] args)
        {
            Console.WriteLine("Enter Convert-PEM-TO-XML to convert private key from PEM format to XML");
            Console.WriteLine("Enter CreateCannedPrivateURL for generating signed URL for s3 object that is distributed through CloudFront");
            var choice= Console.ReadLine();

            switch (choice)
            {
                case "Convert-PEM-TO-XML":
                    string privateKey = await File.ReadAllTextAsync("private_key.pem");
                    var rsa = RSA.Create();
                    var bytesToDecrypt = Convert.FromBase64String(privateKey);
                    rsa.ImportRSAPrivateKey(bytesToDecrypt, out var byc);

                    var d = new XmlDocument();
                    d.LoadXml(rsa.ToXmlString(true));
                    d.Save("private_key_xml.xml");
                    break;

                case "CreateCannedPrivateURL":

                    // get the CF DNS from the Terraform script output values (ex:dfd8w3fi9tet3.cloudfront.net;)
                    Console.WriteLine("Enter Cloud Front DNS");
                    var CF_DNS = Console.ReadLine();
                    Console.WriteLine("Enter S3 object key");
                    // upload a file in S3 and assign object name as follows. (ex: "main.tf")
                    var s3file = Console.ReadLine();
                    //get the public key Id from the Terraform output values (ex: "K2WWZKWQ3LKMM8")
                    Console.WriteLine("Enter CF publicKeyId");
                    var publicKeyId = Console.ReadLine();
                    var signedURL = CreateCannedPrivateURL("https://"+ CF_DNS+"/"+ s3file, "days", "3", "CannedPolicy.txt", @"C:\Users\siri\Desktop\Srikar\AWS Study\Signed\private_key_xml.xml", publicKeyId);
                    Console.WriteLine($"Singed URL: { signedURL}");
                    Console.WriteLine("Enter any key");
                    Console.ReadLine();
                    break;
                default:
                    Console.WriteLine("Enter valid input");
                    break;
            }

        }


        public static string ToUrlSafeBase64String(byte[] bytes)
        {
            return System.Convert.ToBase64String(bytes)
                .Replace('+', '-')
                .Replace('=', '_')
                .Replace('/', '~');
        }

        public static string CreateCannedPrivateURL(string urlString, string durationUnits,
            string durationNumber, string pathToPolicyStmnt, string pathToPrivateKey, string privateKeyId)
        {
            // args[] 0-thisMethod, 1-resourceUrl, 2-seconds-minutes-hours-days to expiration, 3-numberOfPreviousUnits, 
            // 4-pathToPolicyStmnt, 5-pathToPrivateKey, 6-PrivateKeyId

            TimeSpan timeSpanInterval = GetDuration(durationUnits, durationNumber);

            // Create the policy statement.
            string strPolicy = CreatePolicyStatement(pathToPolicyStmnt,
                urlString, DateTime.Now, DateTime.Now.AddDays(1), "0.0.0.0/0");
            if ("Error!" == strPolicy) return "Invalid time frame.  Start time cannot be greater than end time.";

            // Copy the expiration time defined by policy statement.
            string strExpiration = CopyExpirationTimeFromPolicy(strPolicy);

            // Read the policy into a byte buffer.
            byte[] bufferPolicy = Encoding.ASCII.GetBytes(strPolicy);

            // Initialize the SHA1CryptoServiceProvider object and hash the policy data.
            using (SHA1CryptoServiceProvider cryptoSHA1 = new SHA1CryptoServiceProvider())
            {
                bufferPolicy = cryptoSHA1.ComputeHash(bufferPolicy);

                // Initialize the RSACryptoServiceProvider object.
                RSACryptoServiceProvider providerRSA = new RSACryptoServiceProvider();
                XmlDocument xmlPrivateKey = new XmlDocument();

                // Load the PrivateKey.xml file generated by ConvertPEMtoXML.
                xmlPrivateKey.Load(pathToPrivateKey);

                // Format the RSACryptoServiceProvider providerRSA and create the signature.
                providerRSA.FromXmlString(xmlPrivateKey.InnerXml);
                RSAPKCS1SignatureFormatter rsaFormatter = new RSAPKCS1SignatureFormatter(providerRSA);
                rsaFormatter.SetHashAlgorithm("SHA1");
                byte[] signedPolicyHash = rsaFormatter.CreateSignature(bufferPolicy);

                // Convert the signed policy to URL safe base 64 encoding.
                string strSignedPolicy = ToUrlSafeBase64String(signedPolicyHash);

                // Concatenate the URL, the timestamp, the signature, and the key pair ID to form the private URL.
                return urlString + "?Expires=" + strExpiration + "&Signature=" + strSignedPolicy + "&Key-Pair-Id=" + privateKeyId;
            }
        }

        public static string CreatePolicyStatement(string policyStmnt, string resourceUrl,
                               DateTime startTime, DateTime endTime, string ipAddress)
        {
            startTime = DateTime.Now;
            endTime = DateTime.Now.AddDays(1);
            // Create the policy statement.
            FileStream streamPolicy = new FileStream(policyStmnt, FileMode.Open, FileAccess.Read);
            using (StreamReader reader = new StreamReader(streamPolicy))
            {
                string strPolicy = reader.ReadToEnd();

                TimeSpan startTimeSpanFromNow = (startTime - DateTime.Now);
                TimeSpan endTimeSpanFromNow = (endTime - DateTime.Now);
                TimeSpan intervalStart =
                    (DateTime.UtcNow.Add(startTimeSpanFromNow)) - new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc);
                TimeSpan intervalEnd =
                    (DateTime.UtcNow.Add(endTimeSpanFromNow)) - new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc);

                int startTimestamp = (int)intervalStart.TotalSeconds; // START_TIME
                int endTimestamp = (int)intervalEnd.TotalSeconds;  // END_TIME

                if (startTimestamp > endTimestamp)
                    return "Error!";

                // Replace variables in the policy statement.
                strPolicy = strPolicy.Replace("RESOURCE", resourceUrl);
                strPolicy = strPolicy.Replace("START_TIME", startTimestamp.ToString());
                strPolicy = strPolicy.Replace("END_TIME", endTimestamp.ToString());
                strPolicy = strPolicy.Replace("IP_ADDRESS", ipAddress);
                strPolicy = strPolicy.Replace("EXPIRES", endTimestamp.ToString());
                return strPolicy;
            }
        }

        public static TimeSpan GetDuration(string units, string numUnits)
        {
            TimeSpan timeSpanInterval = new TimeSpan();
            switch (units)
            {
                case "seconds":
                    timeSpanInterval = new TimeSpan(0, 0, 0, int.Parse(numUnits));
                    break;
                case "minutes":
                    timeSpanInterval = new TimeSpan(0, 0, int.Parse(numUnits), 0);
                    break;
                case "hours":
                    timeSpanInterval = new TimeSpan(0, int.Parse(numUnits), 0, 0);
                    break;
                case "days":
                    timeSpanInterval = new TimeSpan(int.Parse(numUnits), 0, 0, 0);
                    break;
                default:
                    Console.WriteLine("Invalid time units; use seconds, minutes, hours, or days");
                    break;
            }
            return timeSpanInterval;
        }

        public static string CopyExpirationTimeFromPolicy(string policyStatement)
        {
            int startExpiration = policyStatement.IndexOf("EpochTime");
            string strExpirationRough = policyStatement.Substring(startExpiration + "EpochTime".Length);
            char[] digits = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' };
            List<char> listDigits = new List<char>(digits);
            StringBuilder buildExpiration = new StringBuilder(20);
            foreach (char c in strExpirationRough)
            {
                if (listDigits.Contains(c))
                    buildExpiration.Append(c);
            }
            return buildExpiration.ToString();
        }


    }
}
